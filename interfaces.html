<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.55">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="mlsquare">

<title>Interfaces – Compressive Learning</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./tasks.html" rel="next">
<link href="./sparse_bnn_layer.html" rel="prev">
<link href="./logo.jpg" rel="icon" type="image/jpeg">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./interfaces.html"><span class="chapter-title">Interfaces</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Compressive Learning</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/mlsquare/CompressiveLearning" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./preface.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Motivation</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Compressive Learning</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./bold.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Boolean Variation</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./bnn_layer.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">BNN Layer</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./sparse_bnn_layer.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Sparse BNN Layer</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./interfaces.html" class="sidebar-item-text sidebar-link active"><span class="chapter-title">Interfaces</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./tasks.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Tasks</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Notebooks</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./bolt/notebooks/dev.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Boolean Variation</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#pure-bnn" id="toc-pure-bnn" class="nav-link active" data-scroll-target="#pure-bnn">Pure BNN</a></li>
  <li><a href="#mixed-bnn" id="toc-mixed-bnn" class="nav-link" data-scroll-target="#mixed-bnn">Mixed BNN</a></li>
  <li><a href="#converters-not-trainable" id="toc-converters-not-trainable" class="nav-link" data-scroll-target="#converters-not-trainable">Converters (not trainable)</a>
  <ul class="collapse">
  <li><a href="#adc-coder" id="toc-adc-coder" class="nav-link" data-scroll-target="#adc-coder">ADC Coder:</a></li>
  <li><a href="#dac-coder" id="toc-dac-coder" class="nav-link" data-scroll-target="#dac-coder">DAC Coder:</a></li>
  </ul></li>
  <li><a href="#adapters-trainable" id="toc-adapters-trainable" class="nav-link" data-scroll-target="#adapters-trainable">Adapters (trainable)</a>
  <ul class="collapse">
  <li><a href="#adc-layer" id="toc-adc-layer" class="nav-link" data-scroll-target="#adc-layer">ADC Layer:</a></li>
  <li><a href="#dac-layer" id="toc-dac-layer" class="nav-link" data-scroll-target="#dac-layer">DAC Layer:</a></li>
  <li><a href="#compressive-sensing-2" id="toc-compressive-sensing-2" class="nav-link" data-scroll-target="#compressive-sensing-2">Compressive Sensing</a></li>
  <li><a href="#a1-fista" id="toc-a1-fista" class="nav-link" data-scroll-target="#a1-fista">A1: FISTA:</a></li>
  <li><a href="#a2-rich-b-1" id="toc-a2-rich-b-1" class="nav-link" data-scroll-target="#a2-rich-b-1">A2: Rich B-1:</a></li>
  <li><a href="#a3-rich-b-2" id="toc-a3-rich-b-2" class="nav-link" data-scroll-target="#a3-rich-b-2">A3: Rich B-2:</a></li>
  <li><a href="#a4-gopi-et-al" id="toc-a4-gopi-et-al" class="nav-link" data-scroll-target="#a4-gopi-et-al">A4: Gopi et al:</a></li>
  <li><a href="#zeng-et-al" id="toc-zeng-et-al" class="nav-link" data-scroll-target="#zeng-et-al">Zeng et al:</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/mlsquare/CompressiveLearning/edit/main/interfaces.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/mlsquare/CompressiveLearning/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-title">Interfaces</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>For a strictly Boolean-in and Boolean-out type functions, the <a href="./bnn_layer.html">BNN layer</a> or the <a href="./sparse_bnn_layer.html">Sparse BNN Layer</a> are supposed to work. For example, learning a parity checker which takes <span class="math inline">\(n\)</span> Boolean inputs and outputs a single Boolean value. But that is somewhat restrictive in a way, if we want wider adoption of BNNs. The BNN layer as a replacement for an MLP needs different <em>adapters</em> depending on the type of modeling it is involved in.</p>
<p>Obviously, BNN only works on Bool variables (which we can all Pure BNN). But what if we want to embed BNN layer in DNN and co-train mixed precision layers (which we can call mixed BNN), together in an end-to-end fashion. It changes the game. We need an ability convert reals to Bools and vice-versa.</p>
<p>Terms used to refer to the interfaces:</p>
<ul>
<li>Analog to Digital = A/D = Analog to Digital Converter = ADC</li>
<li>Digital to Analog = D/A = Digital to Analog Converter = DAC</li>
</ul>
<section id="pure-bnn" class="level2">
<h2 class="anchored" data-anchor-id="pure-bnn">Pure BNN</h2>
<p>First consider the case where BNN is all there is. No upstream or downstream blocks.</p>
<ul>
<li><p>Bool-in, Bool-out:</p>
<p>Any boolean truth tables and digital circuits. Example - parity checker!</p></li>
<li><p>Real-in, Bool-out:</p>
<p>Most binary classification problems fall under this category. One <em>Hello world</em> example is the Iris Flower classification problem. Take the features measured on a Flower and identify the Flower class. Here, we need to convert <span class="math inline">\(x \in \mathcal{R}^n\)</span> to <span class="math inline">\(\{-1,1\}^p\)</span> for some <span class="math inline">\(p\)</span>, and chain BNN layers. Binary Classification labels can be coded as <span class="math inline">\(\{-1,1\}\)</span>. By extension, multi-label or multi-class can be handled as multi-valued Truth Tables. <em>We need to convert the real inputs to Boolean valued inputs.</em></p></li>
<li><p>Real-in, Real-out:</p>
<p>A more complicated problem is when the outputs are real valued. Consider a regression problem with real valued output. We need to code real-valued signal and realize this as a multi-valued Truth table.</p></li>
</ul>
<p>We need codings that convert analog to digital and digital (binary) to analog but these converters act like pre- and post-processors (i.e., they are not part of the trainable layers).</p>
</section>
<section id="mixed-bnn" class="level2">
<h2 class="anchored" data-anchor-id="mixed-bnn">Mixed BNN</h2>
<ul>
<li><p>Real-in, Bool-out:</p>
<p>Here, a BNN Layer is appended to DNN. The DNN layers are trainable which produce real valued outputs. An example could be to train an image classifier based on ResNet head, which also needs to be trained. How do we design the interface (A/D converter) that flows the gradients from BNN to a Conv Layer, for example?</p></li>
<li><p>Real-in, Real-out:</p>
<p>Here, a BNN layer is sandwiched between two DNN layers (or modules). The BNN receives a real valued input and has to pass a continuous valued signal for the downstream DNN layer. For example, we want to fine-tune an LLM with LoRA (like Bit LoRA) - What would the D/A converter look like?</p></li>
</ul>
</section>
<section id="converters-not-trainable" class="level2">
<h2 class="anchored" data-anchor-id="converters-not-trainable">Converters (not trainable)</h2>
<p>The A/D and D/A converters pre-process and post-process the data, and therefore can be considered as not part of the BNN.</p>
<section id="adc-coder" class="level3">
<h3 class="anchored" data-anchor-id="adc-coder">ADC Coder:</h3>
<section id="quantile-binning" class="level4">
<h4 class="anchored" data-anchor-id="quantile-binning">Quantile Binning</h4>
<p>Consider all inputs to be an n-dimensional real valued input. For every dimension, compute the CDF, divide it into bins of equal width, map the input feature to the bin it points to. The bins are one-hot coded. See sklearn’s <a href="https://scikit-learn.org/1.5/modules/generated/sklearn.preprocessing.KBinsDiscretizer.html">KBinsDiscretizer</a></p>
</section>
</section>
<section id="dac-coder" class="level3">
<h3 class="anchored" data-anchor-id="dac-coder">DAC Coder:</h3>
<section id="bit-plane-coding" class="level4">
<h4 class="anchored" data-anchor-id="bit-plane-coding">Bit Plane Coding</h4>
<p>Quantize the output to the precision needed. Do a bit-plane coding. Note that errors on MSBs are much costlier than the LSBs. Further, we are not interesting in compressing the bit-planes - just use the bit-planes to code a quantized real-valued signal so that BNN can be learnt on them.</p>
<p>After predicting the bit-planes, de-quantize.</p>
</section>
</section>
</section>
<section id="adapters-trainable" class="level2">
<h2 class="anchored" data-anchor-id="adapters-trainable">Adapters (trainable)</h2>
<p>The A/D and D/A adapters must allow BNN Layer to be added before/after a DNN layer, and enable training end-to-end.</p>
<section id="adc-layer" class="level3">
<h3 class="anchored" data-anchor-id="adc-layer">ADC Layer:</h3>
<section id="random-binning-features" class="level4">
<h4 class="anchored" data-anchor-id="random-binning-features">Random Binning Features</h4>
<p>See <a href="https://people.eecs.berkeley.edu/~brecht/papers/07.rah.rec.nips.pdf">paper</a>.</p>
</section>
<section id="compressive-sensing" class="level4">
<h4 class="anchored" data-anchor-id="compressive-sensing">Compressive Sensing:</h4>
<p>Map real input <span class="math inline">\(x_{n \times 1}\)</span> to <span class="math inline">\(b^{in}_{m \times 1} = \text{sign}(\Phi x)\)</span>, with <span class="math inline">\(\Phi \sim N(0,1)\)</span>. It is possible to have <span class="math inline">\(\Phi\)</span> from <span class="math inline">\(\{0,1\}\)</span> as well.</p>
<p>A related idea is to consider <span class="math inline">\(b = \text{sign}(\tau u^Tx ) \text{ s.t } ||u|| = 1, \tau \in (0,1)\)</span>. Here, we can interpret <span class="math inline">\(u\)</span> as the directional vector, and <span class="math inline">\(\tau\)</span> is the scaling factor that measures the Half-space depth. When combined, they can be used to estimate depth quantiles, a generalized notion of quantiles, extended to multivariarte case. Depth Quantiles, Directional Quantiles, Tukey’s Half-spaces are related to Half-spaces fundamental in ML (in SVMs, we refer to them as the separating Hyperplanes, and max-margin algo finds them).</p>
<p>See</p>
<ul>
<li>1-bit Compressive Sensing <a href="https://arxiv.org/abs/1104.3160">paper</a></li>
<li><a href="https://arxiv.org/abs/0805.0056">Quantile Tomography: USsing Quantiles with multivariate data</a></li>
<li><a href="https://arxiv.org/abs/1002.4486">Multivariate quantiles and multiple-output regression quantiles: From L1 optimization to half-space depth</a>.</li>
</ul>
<p><strong>Forward Pass</strong></p>
<p>Input: <span class="math inline">\(x_{n \times 1} \in \mathcal{R}^n\)</span>, a real-valued n-dim vector. Output: <span class="math inline">\(b_{m \times 1} \in \{-1,1\}^m\)</span>, a discrete valued m-dim vector. Typically <span class="math inline">\(m &gt;&gt; n\)</span>.</p>
<p>Let <span class="math inline">\(\Phi_{m \times n}\)</span> be a known (non-trainable) matrix. The forward pass is: <span class="math inline">\(b = \text{sign}(\Phi x)\)</span></p>
<p>Choice of <span class="math inline">\(\Phi\)</span></p>
<ol type="1">
<li><span class="math inline">\(\Phi \sim N(0,1)\)</span> - every element is drawn from standard normal distribution.</li>
<li><span class="math inline">\(\Phi\)</span> - is designed according to 1-bit CS theory suggested <a href="[One-bit Compressed Sensing: Provable Support and Vector Recovery](https://proceedings.mlr.press/v28/gopi13.pdf)">here</a></li>
<li><span class="math inline">\(\Phi\)</span> s.t <span class="math inline">\(\Phi^T \Phi = \text{Diag}(\tau)\)</span> and elements of <span class="math inline">\(\tau\)</span> can be sampled from <span class="math inline">\(U(0,1)\)</span> or spaced at uniform intervals.</li>
</ol>
<p><strong>Backward Pass</strong></p>
<p>For the forward pass of the form <span class="math inline">\(b = \text{sign}(\Phi x)\)</span></p>
<p>Option-1: With Straight Through Estimator (STE), replacing the non-differential function with Identity, the local derivative is: <span class="math display">\[
\frac{\partial{b}}{\partial{x}} =
\begin{cases}
\Phi &amp; \text{ if } |x| &lt; 1 \\
0 &amp; \text{ o.w }
\end{cases}
\]</span></p>
<p>Option-2: We implement a smooth approximation of the <span class="math inline">\(\text{sign}\)</span> function, with a scheduler that controls the approximation (smoothness) over the course of the training. Consider, <span class="math inline">\(\text{sign}(x) = \lim_{\alpha \to \infty} \text{tanh}(\alpha x)\)</span></p>
<p><span class="math display">\[
\frac{\partial{b}}{\partial{x}} =
\begin{cases}
\alpha\text{sech}^2(\alpha\Phi) &amp; \text{ if } |x| &lt; 1 \\
0 &amp; \text{ o.w }
\end{cases}
\]</span></p>
<p>Obviously, <span class="math inline">\(\alpha\)</span> can not be too large. During the course of the training, it can follow a scheduling regime. It being constant is one of the choices for example. If <span class="math inline">\(\alpha\)</span> is fixed, and we use <span class="math inline">\(\text{tanh}\)</span> function in <code>torch</code>, we do not need to code any custom <code>backprop</code> functions.</p>
</section>
</section>
<section id="dac-layer" class="level3">
<h3 class="anchored" data-anchor-id="dac-layer">DAC Layer:</h3>
<section id="compressive-sensing-1" class="level4">
<h4 class="anchored" data-anchor-id="compressive-sensing-1">Compressive Sensing:</h4>
<p>Problem: Given a signs <span class="math inline">\(+/-1\)</span> vector alone and the sensing matrix, recover a real-valued sparse signal. That is, recover <span class="math inline">\(y_{k \times 1} \in \mathcal{R}^k\)</span> from <span class="math inline">\(b^{out}_{m \times 1} \in \{-1,1\}^m\)</span> given a sensing matrix <span class="math inline">\(\Phi\)</span> which is hypothesized to have generated the measurements <span class="math inline">\(b =  \Phi y\)</span>.</p>
<p>See the papers</p>
<ol type="1">
<li><a href="https://arxiv.org/abs/1104.3160">Robust 1-Bit Compressive Sensing via Binary Stable Embeddings of Sparse Vectors</a></li>
<li><a href="https://proceedings.mlr.press/v28/gopi13.pdf">One-bit Compressed Sensing: Provable Support and Vector Recovery</a></li>
<li><a href="https://arxiv.org/abs/2212.01076">Are Straight-Through gradients and Soft-Thresholding all you need for Sparse Training?</a></li>
<li><a href="https://icml.cc/Conferences/2010/papers/449.pdf">Learning Fast Approximations of Sparse Coding</a></li>
<li><a href="https://www.esann.org/sites/default/files/proceedings/legacy/es2018-81.pdf">Revisiting FISTA for Lasso: Acceleration Strategies Over The Regularization Path</a></li>
</ol>
<p><strong>Forward Pass</strong></p>
<p>At the heart, recovering sparse signal <span class="math inline">\(y\)</span> from an observed binary signal <span class="math inline">\(b\)</span> is exactly the linear regression with <span class="math inline">\(l_1\)</span> penalty, and it can be solved by iterative optimization techniques like projected coordinate descent, ISTA, FISTA, among others. We can interpret each time step of the the optimization process as a layer in the Deep Learning. The number of steps in the optimization correspond to the depth of the unrolling.</p>
<p>We want to write the optimization step for solving <span class="math inline">\(b = \Phi y\)</span>, subject some constraints on the sparsity of the recovered signal. We consider the FISTA steps. See <a href="https://www-users.cse.umn.edu/~boley/publications/papers/fistaPaperP.pdf">this</a> for reference. We are seeking a solution to</p>
<p><span class="math display">\[
\min_{y \in \mathcal{R}^k } \, \, \frac{1}{2} || \Phi y - b || + \lambda ||y||_{1}
\]</span> which is precisely the lasso linear regression. The projected gradient descent provides an estimate to the solution, outlined below.</p>
<ol type="1">
<li>Initialize: <span class="math inline">\(y_{0}, y_{-1}=0, \eta_0=1\)</span>. Input <span class="math inline">\(L, \lambda\)</span>. For <span class="math inline">\(t=1,2,..,T\)</span> Run T steps.</li>
<li><span class="math inline">\(\eta_{t} = \frac{1}{2}\left(1+ \sqrt{1+4 \eta_{t-1}^2} \right)\)</span></li>
<li><span class="math inline">\(w_{t} = y_{t-1} + \frac{\eta_{t-1}-1}{\eta_{t}}(y_{t-1}-y_{t-2})\)</span></li>
<li><span class="math inline">\(y_{t} = S_{\lambda/L}( w_t - \frac{1}{L} \left( [\Phi^T \Phi] w_t + \frac{1}{L}\Phi^T b \right) )\)</span></li>
<li>Assign <span class="math inline">\(y = y_T\)</span> as the output to be connected to downstream layer.</li>
</ol>
<p>Here <span class="math inline">\(S_{\gamma}\)</span> is the soft-thresholding operator defined as <span class="math inline">\(S_{\gamma}(x) = \text{sign}(x) \text{ReLU}(|x|-\gamma)\)</span> and <span class="math inline">\(L\)</span> is an estimate of the Lipschitz constant.</p>
<p><strong>Backward Pass</strong></p>
<p>In the Forward Pass, except for the <span class="math inline">\(S_{\gamma}\)</span> – all are differentiable operators. Below are some options.</p>
<p>Option-1: We can define a smooth version of <span class="math inline">\(S_{\gamma}\)</span> as follows: <span class="math display">\[
S_{\gamma} =
\begin{cases}
x-\gamma(1-\epsilon) &amp; \text{ if } x \ge \gamma \\
\epsilon x &amp; \text{ if  }  -\gamma &lt; x &lt; \gamma \\
x-\gamma(1-\epsilon) &amp; \text{ if } x \le \gamma \\
\end{cases}
\]</span> We can see it exactly fits when <span class="math inline">\(\epsilon=0\)</span>. Its gradients can now be defined: <span class="math display">\[
\frac{\partial S_{\gamma}}{\partial x} =
\begin{cases}
1 &amp; \text{ if } x \ge \gamma \\
\epsilon  &amp; \text{ if  }  -\gamma &lt; x &lt; \gamma \\
1 &amp; \text{ if } x \le \gamma \\
\end{cases}
\]</span></p>
<p>Option-2: Like before, replace <span class="math inline">\(\text{sign}\)</span> function with its smooth version. For example, <span class="math inline">\(S_{\gamma}(x) = \text{tanh}(x) \text{ReLU}(|x|-\gamma)\)</span>. (check if <span class="math inline">\(|x\)</span>| returns <code>grad</code> in <code>Torch</code>).</p>
<p>Option-3: Replace the soft-thresholding with identify, and pass the gradients.</p>
<p>Note: If the sensing matrix <span class="math inline">\(\Phi\)</span> is carefully chosen (Unitary, for example), the FISTA becomes lot simpler, and some terms can be cached, the key recurrence expression simplifies to <span class="math display">\[
\begin{array}{left}
y_{t} &amp;=&amp; S_{\lambda/L}( w_t - \frac{1}{L} \left( [\Phi^T \Phi] w_t + \frac{1}{L}\Phi^T b \right) )
&amp; \approx &amp; S_{\lambda/L}(\tilde{w}_t)
\end{array}
\]</span> where <span class="math inline">\(\tilde{w}_t = \tilde{a} w_t + \tilde{b}\)</span>, with <span class="math inline">\(\tilde{a} = (1-1/L), \tilde{b}= \frac{1}{L}\Phi^T b\)</span> that are constant through the steps.</p>
</section>
</section>
<section id="compressive-sensing-2" class="level3">
<h3 class="anchored" data-anchor-id="compressive-sensing-2">Compressive Sensing</h3>
<p>We assume a measurement model of the form</p>
<p><span class="math display">\[
b = \text{sign}(\Phi y)
\]</span></p>
</section>
<section id="a1-fista" class="level3">
<h3 class="anchored" data-anchor-id="a1-fista">A1: FISTA:</h3>
<p><a href="https://www-users.cse.umn.edu/~boley/publications/papers/fistaPaperP.pdf">Details</a></p>
<p><strong>Objective</strong> <span class="math display">\[
\min_{y \in \mathcal{R}^k } \, \, \frac{1}{2} || \Phi y - b || + \lambda ||y||_{1}
\]</span> which is precisely the lasso linear regression. The projected gradient descent provides an estimate to the solution, outlined below.</p>
<p><strong>Optimization Loop</strong></p>
<ol type="1">
<li>Initialize: <span class="math inline">\(y_{0}, y_{-1}=0, \eta_0=1\)</span>. Input <span class="math inline">\(L, \lambda\)</span>. For <span class="math inline">\(t=1,2,..,T\)</span> Run T steps.</li>
<li><span class="math inline">\(\eta_{t} = \frac{1}{2}\left(1+ \sqrt{1+4 \eta_{t-1}^2} \right)\)</span></li>
<li><span class="math inline">\(w_{t} = y_{t-1} + \frac{\eta_{t-1}-1}{\eta_{t}}(y_{t-1}-y_{t-2})\)</span></li>
<li><span class="math inline">\(y_{t} = S_{\lambda/L}( w_t - \frac{1}{L} \left( [\Phi^T \Phi] w_t + \frac{1}{L}\Phi^T b \right) )\)</span></li>
<li>Assign <span class="math inline">\(y = y_T\)</span> as the output to be connected to downstream layer.</li>
</ol>
<p>Here <span class="math inline">\(S_{\gamma}\)</span> is the soft-thresholding operator defined as <span class="math inline">\(S_{\gamma}(x) = \text{sign}(x) \text{ReLU}(|x|-\gamma)\)</span> and <span class="math inline">\(L\)</span> is an estimate of the Lipschitz constant.</p>
<p>Notice that here we have not enforced the constraint that <span class="math inline">\(b\)</span> is strictly in <span class="math inline">\(\{-1,1\}\)</span>. But solution obtained could be a could hueristic and can be applied in together with other decoders.</p>
</section>
<section id="a2-rich-b-1" class="level3">
<h3 class="anchored" data-anchor-id="a2-rich-b-1">A2: Rich B-1:</h3>
<p><a href="https://arxiv.org/abs/1104.3160">Details</a> Section 4.1</p>
</section>
<section id="a3-rich-b-2" class="level3">
<h3 class="anchored" data-anchor-id="a3-rich-b-2">A3: Rich B-2:</h3>
<p><a href="https://boufounos.com/Publications/Boufounos_Baraniuk_CISS08.pdf">Details</a></p>
<p><strong>Objective</strong></p>
<p><span class="math display">\[
\begin{array}{left}
\min_{y \in \mathcal{R}^k} &amp;&amp; ||y||_{1}  \, \, + \lambda \sum_i f\left( b_i \Phi y_i \right) \\
&amp;&amp; \text{ s.t } ||y||_2 = 1
\end{array}
\]</span> Here, some additional constraints are imposed. The solution must be sparse (1st term), it must obey the sign constraints (2nd term), and it needs to have unit norm (to fix identifiability w.r.t scale). <span class="math inline">\(f(.)\)</span> is chosen as <span class="math inline">\(0.5x^2 \text{ReLU}(-x)\)</span>.</p>
<p><strong>Optimization Loop</strong></p>
<p>Algorithm 1, Sec 3.C</p>
<ol type="1">
<li>Initialize: <span class="math inline">\(y_{0}\)</span> s.t <span class="math inline">\(||y_0||_2 = 1\)</span>. Input <span class="math inline">\(\eta\)</span> step size. Define <span class="math inline">\(B = \text{Diag}(b), \bar{f} = \sum_{i}f(y_i)\)</span>. For <span class="math inline">\(t=1,2,..,T\)</span>. Run T steps.</li>
<li><span class="math inline">\(\bar{f}_t = (B\Phi)^T \bar{f}'(B \Phi y_{t-1})\)</span></li>
<li><span class="math inline">\(\tilde{f}_t = \bar{f}_t - &lt;\bar{f}_t, y_{t-1}&gt; y_{t-1}\)</span></li>
<li><span class="math inline">\(h=y_{t-1} - \eta \tilde{f}_t\)</span></li>
<li>Shrink coordinate-wise: <span class="math inline">\(u_i = S_{\frac{\eta}{\lambda}}(h_i)\)</span></li>
<li>Normalize: <span class="math inline">\(y_{t+1} = \frac{u}{||u||_2}\)</span></li>
<li>Assign <span class="math inline">\(y = y_T\)</span> as the output to be connected to downstream layer.</li>
</ol>
<p>FISTA is good starting point (initialization)</p>
</section>
<section id="a4-gopi-et-al" class="level3">
<h3 class="anchored" data-anchor-id="a4-gopi-et-al">A4: Gopi et al:</h3>
<p>Section 5, Algo 6, <a href="https://proceedings.mlr.press/v28/gopi13.html">Details</a></p>
<p>We assume a measurement model of the form</p>
<ol type="1">
<li><span class="math inline">\(b = \text{sign}(\Phi y)\)</span>, where <span class="math inline">\(\Phi = A_2 A_1\)</span>.</li>
<li>The sensing matrix <span class="math inline">\(A_1\)</span> can be standard CS matrix (eg. drawn from any sub Gaussian such as symmetric, bounded uniform distribution or even a Bernoulli).</li>
<li><span class="math inline">\(A_2\)</span> can be drawn from standard Gaussian.</li>
</ol>
<p><strong>Objective</strong></p>
<p>Given <span class="math inline">\(b = \text{sign}(\Phi y)\)</span>, where <span class="math inline">\(\Phi = A_2 A_1\)</span>. Find <span class="math inline">\(y \in \mathcal{R}^k\)</span> s.t</p>
<p><span class="math display">\[
\begin{array}{left}
&amp;&amp; ||y||_{0} \le \tilde{k} \\
&amp;&amp; ||y||_2 = 1 \\
&amp;&amp; ||y* - \hat{y}|| &lt; \epsilon
\end{array}
\]</span></p>
<p>which basically is saying, the non-zero terms in <span class="math inline">\(y\)</span> should not be more than <span class="math inline">\(\tilde{k}\)</span> (pre-specified number), it should have unit norm, and the approximation error has to be no more than <span class="math inline">\(\epsilon\)</span>.</p>
<p><strong>Optimization Loop</strong></p>
<p>Algorithm 5 from the paper is a two-stage process.</p>
<ol type="1">
<li>Recover <span class="math inline">\(z\)</span> as a solution to <span class="math inline">\(b =A_2 z\)</span>. Standard LP solver (an SVM formulation should work)
<ul>
<li><a href="https://home.ttic.edu/~nati/Publications/PegasosMPB.pdf">pegasos</a> algo for SVMs via subgradients.</li>
<li>Objective: <span class="math inline">\(\min_{z \in \mathcal{R}^h} \frac{\lambda}{2} ||z||_2 + \sum_i \text{ReLU}(1-b_i\langle [A_2]_i,z \rangle)\)</span></li>
<li>Loop:
<ul>
<li><span class="math inline">\(\eta_t = \frac{1}{\lambda t}\)</span>. Other learning rates are possible. Can accelerate this with momentum.</li>
<li>$z^i_{t} = (1-<em>t) z^i</em>{t-1} + _t H(1-b_i_i,z_t^i) b_i $z^i_t</li>
</ul></li>
<li>The <a href="https://arxiv.org/pdf/1901.01585">L1-SVM</a> is a better candidate here, provided a PGD update is available.</li>
<li>One could also use A3.</li>
</ul></li>
<li>Given <span class="math inline">\(z\)</span>, recover <span class="math inline">\(y\)</span> as a solution to <span class="math inline">\(z =A_1 y\)</span>, which is a standard CS technique. FISTA should work here or <a href="https://icml.cc/Conferences/2009/papers/115.pdf">GraDeS</a>.
<ul>
<li><span class="math inline">\(y_t = H_{\tilde{k}}(y_{t-1} + \frac{1}{\gamma}A_1^T(z-A_1 y_{t-1}))\)</span></li>
<li>Here <span class="math inline">\(\gamma  = 1+\delta_{2s}\)</span>, an isometry constant (<span class="math inline">\(\delta_{2s} &lt; 1/3\)</span>). <span class="math inline">\(A_1\)</span> is standard CS sensing matrix and <span class="math inline">\(H_{\tilde{k}}\)</span> retains at most <span class="math inline">\(\tilde{k}\)</span> non-zero coordinates and sets others to 0 (an adaptive hard thresholding operator).</li>
</ul></li>
</ol>
</section>
<section id="zeng-et-al" class="level3">
<h3 class="anchored" data-anchor-id="zeng-et-al">Zeng et al:</h3>
<p><a href="https://arxiv.org/abs/2203.11278">Details</a> Trainable Compressive Sensing, where the sensing matrix need not be known exactly, and they introduced a method called, Deep Unfolding. It could be suitable as a “trainable” Compressive Sensing (DAC) Network.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/mlsquare\.github\.io\/CompressiveLearning");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./sparse_bnn_layer.html" class="pagination-link" aria-label="Sparse BNN Layer">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-title">Sparse BNN Layer</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./tasks.html" class="pagination-link" aria-label="Tasks">
        <span class="nav-page-text"><span class="chapter-title">Tasks</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>methods under prep.</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/mlsquare/CompressiveLearning/edit/main/interfaces.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/mlsquare/CompressiveLearning/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
<p>This material was built with <a href="https://quarto.org/">Quarto</a> with <a href="https://github.com/hadley/r4ds">r4ds</a> theme.</p>
</div>
  </div>
</footer>




</body></html>